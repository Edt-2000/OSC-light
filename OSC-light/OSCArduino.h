#pragma once

// OSC light implementation for Arduino

#include "OSCMessage.h"

// TODO: do not include the things required for testing here
#ifdef _MSC_VER
#include "../OSC-lightUnitTest/Udp.h"
#else
#include <Udp.h>
#endif

namespace OSC {

	// OSC message producer
	class IMessageProducer
	{
	public:
		virtual void loop() = 0;
		virtual Message * generateMessage() = 0;
	};

	// OSC message consumer
	class IMessageConsumer
	{
	public:
		virtual const char * address() = 0;
		virtual void callback(Message *) = 0;
	};

	class Arduino
	{
	public:
		Arduino() {}
		Arduino(int consumers, int producers) {
			_oscConsumers = new IMessageConsumer*[consumers];
			_oscProducers = new IMessageProducer*[producers];
		}

		// binds UDP handle to receive and send OSC messages 
		void bindUDP(UDP * udp, IPAddress remoteIP, int remotePort) {
			_udpHandle = udp;
			_remoteIP = remoteIP;
			_remotePort = remotePort;
		}

		// limits the message consumption to a single IP
		void consumeExclusivelyFrom(IPAddress remoteIP) {
			_exclusiveIP = remoteIP;
			_hasExclusiveIP = true;
		}

		// adds an OSC message consumer
		void addConsumer(IMessageConsumer * consumer) {
			_oscConsumers[_consumers++] = consumer;
		}

		// adds an OSC message producer
		void addProducer(IMessageProducer * producer) {
			_oscProducers[_producers++] = producer;
		}

		// main loop which uses UDP to read messages and feeds the UDP data to each consumer and sends messages generated by producers 
		void loop(bool send = true) {
			int i;
			int size;

			i = 0;

			// first, loop all producer's loop methods, then get all the messages out
			while (i < _producers) {

				_oscProducers[i]->loop();

				if (send) {
					Message * message = _oscProducers[i]->generateMessage();

					if (message->isSendableMessage()) {
						_udpHandle->beginPacket(_remoteIP, _remotePort);
						message->send(_udpHandle);
						_udpHandle->endPacket();
					}

					message->empty();
				}
				++i;
			}

			// then process all the messages in
			if (_consumers > 0) {
				if ((size = _udpHandle->parsePacket()) > 0) {

					// ignore messages which are not from a specific IP
					if (_hasExclusiveIP && _exclusiveIP != _udpHandle->remoteIP()) {
						return;
					}

					// make sure buffer is big enough
					bufferMessage.reserveForProcess(size);

					// write udp data to buffer
					_udpHandle->read(bufferMessage.processBuffer, size);

					// reuse the same message everytime to save repetitive memory allocations
					bufferMessage.process();

					i = 0;
					do {
						if (bufferMessage.isValidRoute(_oscConsumers[i]->address())) {
							_oscConsumers[i]->callback(&bufferMessage);
						}
					} while (++i < _consumers);

					_udpHandle->flush();
				}
			}
			else {
				_udpHandle->flush();
			}
		}

		Message bufferMessage = Message();

	private:
		UDP * _udpHandle;
		IPAddress _exclusiveIP;
		bool _hasExclusiveIP = false;

		IMessageProducer ** _oscProducers;
		IMessageConsumer ** _oscConsumers;

		IPAddress _remoteIP;
		int _remotePort;

		int _producers = 0;
		int _consumers = 0;
	};
}