#pragma once

// OSC light implementation for Arduino
#include "IMessage.h"
#include "OSCMessage.h"
#include "OSCStructMessage.h"
#include "OSCMessageConsumer.h"
#include "OSCMessageProducer.h"

#ifdef UNIT_TEST 
#include <UdpForTest.h>
#include <StreamForTest.h>
#else
#include <Udp.h>
#endif

namespace OSC {

	template <class MessageType = Message>
	class Arduino
	{
	private:
		UDP * _udpHandle;
		Stream * _serialHandle;

		MessageProducer<MessageType> ** _oscProducers;
		MessageConsumer<MessageType> ** _oscConsumers;

		IPAddress _remoteIP;
		int _remotePort;

		int _producers = 0;
		int _consumers = 0;

		bool _useSerial = false;
		bool _useBoth = false;

	public:
		MessageType bufferMessage;

		Arduino() {}

		Arduino(int consumers, int producers) {
			_oscConsumers = new MessageConsumer<MessageType>*[consumers];
			_oscProducers = new MessageProducer<MessageType>*[producers];

			bufferMessage = MessageType();
		}

		// binds UDP handle to receive and send OSC messages 
		void bindUDP(UDP * udp, IPAddress remoteIP, int remotePort) {
			_udpHandle = udp;
			_remoteIP = remoteIP;
			_remotePort = remotePort;
		}

		void bindStream(Stream * serial) {
			_serialHandle = serial;
			_useSerial = true;
		}

		void bindBoth(UDP * udp, IPAddress remoteIP, int remotePort, Stream * serial) {
			bindUDP(udp, remoteIP, remotePort);
			bindStream(serial);

			_useBoth = true;
		}

		// adds an OSC message consumer
		void addConsumer(MessageConsumer<MessageType> * consumer) {
			_oscConsumers[_consumers++] = consumer;
		}

		// adds an OSC message producer
		void addProducer(MessageProducer<MessageType> * producer) {
			_oscProducers[_producers++] = producer;
		}

		// main loop which uses UDP to read messages and feeds the UDP data to each consumer and sends messages generated by producers 
		void loop(bool send = true) {
			int i;
			int size;

			i = 0;

			if (_useBoth || !_useSerial) {
				// first, loop all producer's loop methods, then get all the messages out
				while (i < _producers) {

					_oscProducers[i]->loop();

					if (send) {
						MessageType * message = _oscProducers[i]->generateMessage();

						if (message->isSendableMessage()) {
							_udpHandle->beginPacket(_remoteIP, _remotePort);
							message->send(_udpHandle);
							_udpHandle->endPacket();
						}
					}
					++i;
				}

				// then process all the messages in
				if (_consumers > 0) {
					if ((size = _udpHandle->parsePacket()) > 0) {
						// make sure buffer is big enough
						bufferMessage.reserveBuffer(size);

						// write udp data to buffer
						_udpHandle->read(bufferMessage.processBuffer, size);

						// reuse the same message everytime to save repetitive memory allocations
						bufferMessage.process();

						i = 0;
						do {
							if (bufferMessage.isValidRoute(_oscConsumers[i]->pattern())) {
								_oscConsumers[i]->callbackMessage(&bufferMessage);
							}
						} while (++i < _consumers);
					}
				}
			}
			if (_useBoth || _useSerial) {
				// first, loop all producer's loop methods, then get all the messages out
				while (i < _producers) {

					_oscProducers[i]->loop();

					if (send) {
						IMessage * message = _oscProducers[i]->generateMessage();

						if (message->isSendableMessage()) {
							message->send(_serialHandle);

							message->setValidData(true);
						}
					}
					++i;
				}

				// then process all the messages in
				if (_consumers > 0) {
					if ((size = _serialHandle->available()) > 0) {
						// make sure buffer is big enough
						bufferMessage.reserveBuffer(size);

						// write serial data to buffer
						_serialHandle->readBytes(bufferMessage.processBuffer, size);

						// reuse the same message everytime to save repetitive memory allocations
						if (bufferMessage.process()) {
							i = 0;
							do {
								if (bufferMessage.isValidRoute(_oscConsumers[i]->pattern())) {
									_oscConsumers[i]->callbackMessage(&bufferMessage);
								}
							} while (++i < _consumers);
						}
					}
				}
			}
		}
	};
}